from django2use.library import *

from django.db import models

from django2use.basic.models import *

from .helpers import update_dns_record

from django2use.settings import DYNAMICDNS_PROVIDERS

from jsonfield import JSONField

#*********************************************************************

WEBSITE_TYPEs = (
    ('wp', "WordPress"),

    ('mg', "Magento"),
    ('ps', "PrestaShop"),
)

PROVIDER_CHOICES = [(name, name) for name in DYNAMICDNS_PROVIDERS.keys()]

######################################################################

class Platform(models.Model):
    #owner   = models.ForeignKey(Organism, related_name='platforms', on_delete=models.CASCADE)
    alias   = models.CharField(max_length=64)

    start   = models.DateTimeField(blank=True)
    finis   = models.DateTimeField(blank=True)

    price   = models.FloatField(default=0)

    def __str__(self): return str(self.alias)

#*********************************************************************

class Network(models.Model):
    owner   = models.ForeignKey(Platform, related_name='networks', on_delete=models.CASCADE)
    alias   = models.CharField(max_length=64)

    start   = models.DateTimeField(blank=True)
    finis   = models.DateTimeField(blank=True)

    price   = models.FloatField(default=0)

    def __str__(self): return str(self.alias)

######################################################################

class Domain(models.Model):
    owner   = models.ForeignKey(Organism, related_name='domaines', on_delete=models.CASCADE)
    alias   = models.CharField(max_length=64)

    start   = models.DateTimeField(blank=True)
    finis   = models.DateTimeField(blank=True)

    price   = models.FloatField(default=0)

    def serialize_hook(self, hook):
        # optional, there are serialization defaults
        # we recommend always sending the Hook
        # metadata along for the ride as well
        return {
            'hook': hook.dict(),
            'data': {
                'id': self.id,
                'title': self.title,
                'pages': self.pages,
                'fiction': self.fiction,
                # ... other fields here ...
            }
        }

    def mark_as_read(self):
        # models can also have custom defined events
        from rest_hooks.signals import hook_event
        hook_event.send(
            sender=self.__class__,
            action='read',
            instance=self # the Book object
        )

    user = property(lambda self: self.owner)

    def __str__(self): return str(self.alias)

#*********************************************************************

class Machine(models.Model):
    owner    = models.ForeignKey(Organism, related_name='machines', on_delete=models.CASCADE)
    alias    = models.CharField(max_length=64)
    token    = models.CharField(max_length=50, default=uuid4, help_text='Optional - Autogenerated if left blank')

    mac_addr = models.CharField(max_length=256, blank=True)
    ip4_addr = models.GenericIPAddressField(unpack_ipv4=False, blank=True, verbose_name="IPv4 address", null=True, default=None)
    ip6_addr = models.GenericIPAddressField(unpack_ipv4=True, blank=True, verbose_name="IPv6 address", null=True, default=None)

    hostname = models.CharField(max_length=256)
    provider = models.CharField(max_length=25, choices=PROVIDER_CHOICES, blank=True)
    username = models.CharField(max_length=256, default='root')
    password = models.CharField(max_length=256, blank=True)

    last_time = models.DateTimeField(blank=True, null=True)

    def generate_key(self, size=50, chars=string.ascii_uppercase + string.ascii_lowercase + string.digits):
        return ''.join(random.choice(chars) for x in range(size))

    def save(self):
        if not self.password:
            self.password = self.generate_key()
        update_dns_record(self, self.ip4_addr)
        self.last_time = timezone.now()
        super(Machine, self).save()

    class Meta:
        verbose_name = 'Machine'

    def __str__(self): return str(self.alias)

###############################################################################

class Toolbelt(models.Model):
    alias = models.CharField(max_length=64, unique=True, verbose_name="Program Slug")
    label = models.CharField(max_length=256, verbose_name="Program Name", blank=True)

    helps = models.TextField(blank=True, verbose_name="Description")
    state = models.BooleanField(default=False, verbose_name="Enabled ?")

    website = models.CharField(max_length=256, blank=True, verbose_name="Program Website")
    flavour = models.CharField(max_length=64, choices=SCANNING_TYPEs, default='dns', verbose_name="Data Source")
    command = models.CharField(max_length=1024, verbose_name="Shell command")
    install = models.TextField(blank=True, verbose_name="Install Script")
    updater = models.TextField(blank=True, verbose_name="Updater Script")

    picture = property(lambda self: "%s/toolbelt/%s.png" % (settings.MEDIA_URL, self.alias))

    def rpath(self, *args):
        return os.path.join(self.bpath, *args)

    bpath = property(lambda self: os.path.join(settings.PROG_DIR, self.alias))

    def prepare(self, dry=False):
        cnt = {
            'LIST_DIR': settings.LIST_DIR,
            'PROG_DIR': settings.PROG_DIR,
            'WORK_DIR': settings.WORK_DIR,
            'GOPATH': os.path.join(settings.BASE_DIR, 'thelands'),
            'GOCACHE': os.path.join(settings.BASE_DIR, 'thevault','cache','go-lang'),
            #'GOPATH': "%s/go-modules"
            'PATH': os.environ['PATH'],
        }

        cnt['PATH'] = "%(PATH)s:%(GOPATH)s/bin:%(PROG_DIR)s/massdns/bin" % cnt

        for alias,value in cnt.items():
            cnt[alias] = value

        if self.missing:
            for stmt in self.install.split("\n"):
                for alias,value in cnt.items():
                    while ("$%s" % alias) in stmt:
                        stmt = stmt.replace("$%s" % alias, value)

                if dry:
                    print(stmt)
                else:
                    subprocess.call(stmt, env=cnt, shell=True)

        if not self.missing:
            for item in self.config.all():
                with open(self.rpath(item.path)) as f:
                    f.write(item.conf)

    def invoke(self, task):
        folder = task.rpath(self.alias)

        os.system('mkdir -p %s' % folder)

        os.chdir(folder)

        context = dict(
            base=settings.PROG_DIR,
            name=task.target,
            file=task.rpath(self.source),
            path=folder,
            dest=task.bpath,
        )

        program = self.shell % context

        print(program)

        os.system(program)

    missing = property(lambda self: not (
        os.path.exists(self.bpath)
    or
        os.path.exists(os.path.join(settings.BASE_DIR, 'go-lang', 'bin', self.alias))
    ))

    def handler(self, task):
        resp = getattr(parsing, self.alias, None)

        if callable(resp):
            pass # handler()

    @property
    def __dict__(self):
        resp = super(Toolbelt, self).__dict__

        for key in ['bpath']:
            resp[key] = getattr(self, key, None)

        return resp

    def __str__(self): return str(self.label) or str(self.alias.capitalize())

#*******************************************************************************

class Configuration(models.Model):
    tool = models.ForeignKey(Toolbelt, related_name="config", on_delete=models.CASCADE)

    name = models.CharField(max_length=50, unique=True, verbose_name="Configuration Name")
    flag = models.BooleanField(default=False, verbose_name="Same Folder ?")

    meta = models.TextField(verbose_name="Source Template")
    data = JSONField(blank=True, default=dict, verbose_name="Context Vars")

    @property
    def path(self):
        if self.flag:
            return self.tool.rpath(self.name)
        else:
            return task.rpath(tool.alias,self.name)

    @property
    def conf(self):
        from django.template import engines

        tpl = engines['django'].from_string(self.meta)

        cnt = task.context

        cnt.update(self.data)

        return tpl.render(**cnt)

    def __str__(self): return str(self.name)
